## 散列表
- 数组的一种扩展，查找复杂度O(1)
- 散列冲突
- 装载因子： 填入表中的元素个数 / 容量

#### 散列冲突解决办法
- 开放寻址法：线性探测法（依次往后找一个）；二次探测（）；双重散列（一组散列函数）；
> 特点：更能利用cpu缓存加快查询速度，序列化简单。装载因子不能太大，更浪费空间。

> 数据量小的时候适合：theadlocal

- 链表法每个桶对应一个链表（插入复杂度：正常O(1)吗，最差O(n)）
> 数据量大的时候适合：hashmap

> 内存和空间利用率更高，装载因子可以很大。
> 可以将链表优化为散列表，红黑树等 

#### 如何设计散列冲突
- 不能太复杂
- 散列函数生成的值要尽可能随机并且均匀分布

#### 装载因子
- 过大：散列冲突过多； 过小：浪费内存和空间
- 支持动态扩容的散列表：插入时，若装载因子到达阈值，会发生一次性扩容，复杂度O(n)
- 避免低效扩容：扩容操作分批进行。

#### 工业级散列表
- 特点： 支持快速查询，插入，删除； 内存占用合理；性能稳定
- 做法：合适的散列函数；合适的装载因子和动态扩容策略；合适的散列冲突解决办法

### 散列表和链表
- 可以把LRU算法的时间时间度降为O(1)
- redis有序集合（跳表和散列表） & linkedHashMap


#### 例题

1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
> 遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。

2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

> 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。
