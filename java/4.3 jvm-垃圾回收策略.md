### 内存分配策略
- 静态内存分配（编译时确定大小）（例如java的类和方法中的局部变量以及对象的引用，这些方法运行结束时，对应的就被回收了）
- 栈内存分配（程序入口处确定）（方法的栈帧的分配）
- 堆内存分配（真正运行确定）（对象的分配）

### 判断垃圾回收的标准
- 引用计数   无法处理循环引用，造成内存泄漏
- 可达性分析  java采用

### 根对象
- 方法中局部变量区对象的引用
- java操作栈中的引用
- 常量池中的对象引用
- 本地方法中的对象引用
- 类的Class对象

### 垃圾回收算法
- 复制算法，避免内存碎片化，
- 标记-清除 mark-sweep  会出现碎片化的问题，不适合特别大的堆，不然full GC 暂停时间不可接受
- 标记-整理 mark-compact 类似于标记清除，但是会在清理过程中移动，避免碎片化 

### 垃圾回收策略（只针对堆）
- serial GC：单线程，对年轻代和年老代进行统一的回收，stop the word ： 年轻代：复制  年老代：标记-整理（serial old GC）
- ParNew GC：针对新生代的 serial GC的多线程版本，最常见的应用场景是配合老年代的CMS GC工作
- CMS GC：基于标记-清除算法，尽量较少停顿时间，占用更多CPU，和用户线程争抢，存在内存碎片化的问题，很难避免长时间运行等情况下发生full Gc，
- Parrallel Gc:新生代和年老代GC并行进行，可以设置 暂停时间和吞吐量等目标
- G1 GC: 兼顾吞吐量和停顿时间，是jdk9以后的默认方式。仍然存在年代的概念，但其内存结构并不是简单的条带式划分，而是类似棋盘的一个个region。region之间是复制算法，整体上可看作是标记-清理算法，可以有效地避免内存碎片，尤其是当java堆非常大的时候，G1的又是更明显。






